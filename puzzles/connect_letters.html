<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Connect the Matching Letters — Edge Fix (Clipboard-safe)</title>
  <link rel="stylesheet" href="style.css">
  <style>

    .play-area{
        background:var(--rect);
        border:5px solid #111;
        border-radius:6px;
        height:440px;
        position:relative;
        overflow:hidden
    }

    /* ensure letters are visible above the SVG in all browsers (Edge stacking quirk) */
    svg{
        position:absolute;
        left:0;
        top:0;
        pointer-events:none;
        z-index:1
    }

    .letter{
        width:48px;
        height:40px;
        border:3px solid #111;
        background:transparent;
        display:flex;
        align-items:center;
        justify-content:center;
        position:absolute;
        font-weight:800;
        border-radius:4px;
        user-select:none;
        cursor:pointer;
        z-index:2
    }

    .controls{
        display:flex;
        gap:8px;
        margin-top:12px;
        align-items:center
    }

    .status{
        margin-top:8px;
        font-weight:700
    }

    .swatch{
        display:inline-block;
        width:18px;
        height:18px;
        border-radius:4px;
        margin-right:6px;
        border:2px solid #111
    }
  </style>
</head>
<body>
  <div class="card">
    <h1>Can you solve this?</h1>
    <p class="lead">Connect matching letters without intersecting the paths. Click a letter to start, drag freely to draw any shape, and release on the matching letter (A → A, B → B, C → C).</p>

    <div class="card">
      <div class="play">
        <div id="playArea" class="play-area" aria-label="puzzle area">
          <svg id="svg" width="100%" height="100%"></svg>

          <!-- TWO of each letter (explicit) -->
          <div class="letter" data-letter="A" id="A1" style="left:12%;top:10%" title="A1">A</div>
          <div class="letter" data-letter="A" id="A2" style="right:12%;top:90%" title="A2">A</div>
          
          <div class="letter" data-letter="B" id="B1" style="left:45%;top:0%" title="B1">B</div>
          <div class="letter" data-letter="B" id="B2" style="left:45%;top:90%" title="B2">B</div>
          
          <div class="letter" data-letter="C" id="C1" style="right:12%;top:10%" title="C1">C</div>
          <div class="letter" data-letter="C" id="C2" style="left:12%;top:90%" title="C2">C</div>
        </div>

        <div class="controls">
          <div class="palette">
            <span class="swatch" style="background:#d62728"></span><strong>A</strong>
            <span class="swatch" style="background:#2ca02c;margin-left:12px"></span><strong>B</strong>
            <span class="swatch" style="background:#1f77b4;margin-left:12px"></span><strong>C</strong>
          </div>

          <button id="undo">Undo</button>
          <button id="clear">Clear</button>
          <button id="check">Check</button>
        </div>
        <div class="status" id="status">Draw three paths connecting each pair.</div>
      </div>

      <div class="footbar">
        <div style="background:#ededed;padding:12px;border-radius:8px">
          <h3>More puzzles & resources</h3>
          <p>Click below for more problems like this and math resources (Google Classroom).</p>
          <a id="moreLink" class="link" href="#">Click here for more problems like this / math resources</a>
          <button id="copyLink" style="margin-top:8px">Copy link</button>
          <small>Tip: draw smooth curves — paths can be any shape.</small>
        </div>
      </div>
    </div>
  </div>

  <div class="modal" id="modal">
    <div class="box">
      <h2>Bravo!</h2>
      <p><b>That wasn't too easy.</b> In fact, this problem uses a branch of math called <b>Topology</b>. Want to learn more? Join math club/circle!</p>
      <p><a id="modalLink" href="#" target="_blank">Open the math club / resources</a></p>
      <p style="margin-top:12px"><button id="closeModal">Close</button></p>
    </div>
  </div>

  <script>
    // --- CONFIG ---
    const CLASSROOM_URL = 'https://classroom.google.com/u/1/c/MzIwMTQ2MTIwOTIw';
    const colors = {A:'#d62728', B:'#2ca02c', C:'#1f77b4'};

    // DOM
    const svg = document.getElementById('svg');
    const letters = Array.from(document.querySelectorAll('.letter'));
    const status = document.getElementById('status');
    const moreLink = document.getElementById('moreLink');
    const modal = document.getElementById('modal');
    const modalLink = document.getElementById('modalLink');

    // robust clipboard-copy helper with fallbacks
    function fallbackCopyTextToClipboard(text) {
      try {
        const textArea = document.createElement('textarea');
        textArea.value = text;
        // Avoid scrolling to bottom
        textArea.style.position = 'fixed';
        textArea.style.left = '-9999px';
        document.body.appendChild(textArea);
        textArea.focus();
        textArea.select();
        const successful = document.execCommand('copy');
        document.body.removeChild(textArea);
        return successful;
      } catch (err) {
        return false;
      }
    }

    function copyTextToClipboard(text) {
      return new Promise((resolve, reject) => {
        if (navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard.writeText(text).then(() => resolve(true)).catch(() => {
            // fallback to execCommand
            const ok = fallbackCopyTextToClipboard(text);
            if (ok) resolve(true);
            else reject(new Error('Copy failed'));
          });
        } else {
          const ok = fallbackCopyTextToClipboard(text);
          if (ok) resolve(true);
          else reject(new Error('Copy not supported'));
        }
      });
    }

    // open link safely; fallback to copy + prompt when popups are blocked
    function safeOpen(url){
      let opened = false;
      try{ const w = window.open(url, '_blank', 'noopener'); if(w) opened = true; } catch(e){ opened = false; }
      if(opened) return;
      // popup blocked — try to copy then prompt
      copyTextToClipboard(url).then(()=>{
        alert('Popup blocked — link copied to clipboard. Paste it into your browser address bar to open.');
      }).catch(()=>{
        // last resort: show prompt with the URL so the user can copy it manually
        prompt('Popup blocked. Copy this link and open it manually:', url);
      });
    }

    moreLink.addEventListener('click', e=>{ e.preventDefault(); safeOpen(CLASSROOM_URL); });
    modalLink && modalLink.addEventListener('click', e=>{ e.preventDefault(); safeOpen(CLASSROOM_URL); });
    document.getElementById('copyLink').addEventListener('click', ()=>{
      copyTextToClipboard(CLASSROOM_URL).then(()=>{
        alert('Link copied to clipboard');
      }).catch(()=>{
        prompt('Automatic copy failed. Please copy the link manually:', CLASSROOM_URL);
      });
    });

    // store one polyline per letter (array of points) or null
    const paths = {A:null, B:null, C:null};

    // helpers
    function getCenter(el){
        const r = el.getBoundingClientRect();
        const s = svg.getBoundingClientRect();
        return {x: r.left + r.width/2 - s.left, y: r.top + r.height/2 - s.top};
    }

    function redrawAll(){
        while(svg.firstChild)
            svg.removeChild(svg.firstChild);
        for(const L of ['A','B','C']){
            const poly = paths[L];
            if(!poly)
                continue;
            const el = document.createElementNS('http://www.w3.org/2000/svg','polyline');
            el.setAttribute('points', poly.map(p=>p.x+','+p.y).join(' '));
            el.setAttribute('fill','none');
            el.setAttribute('stroke', colors[L]);
            el.setAttribute('stroke-width',6);
            el.setAttribute('stroke-linecap','round');
            el.setAttribute('stroke-linejoin','round');
            svg.appendChild(el);
        }
    }

    // drawing state
    let active = null; // {letter, startEl, pts, previewEl}

    function startDrawFromElement(startEl, clientX, clientY){
      const letter = startEl.dataset.letter;
      active = {letter, startEl, pts: [ getCenter(startEl) ] };
      const preview = document.createElementNS('http://www.w3.org/2000/svg','polyline');
      preview.setAttribute('points', active.pts.map(p=>p.x+','+p.y).join(' '));
      preview.setAttribute('fill','none');
      preview.setAttribute('stroke', colors[letter]);
      preview.setAttribute('stroke-width',4);
      preview.setAttribute('stroke-linecap','round');
      preview.setAttribute('stroke-linejoin','round');
      preview.setAttribute('data-preview','1');
      svg.appendChild(preview);
      active.previewEl = preview;

      function onMove(ev){
        const clientX = ev.clientX !== undefined ? ev.clientX : (ev.touches && ev.touches[0].clientX);
        const clientY = ev.clientY !== undefined ? ev.clientY : (ev.touches && ev.touches[0].clientY);
        const s = svg.getBoundingClientRect();
        const x = Math.min(s.width,Math.max(0,clientX - s.left));
        const y = Math.min(s.height,Math.max(0,clientY - s.top));
        const last = active.pts[active.pts.length-1];
        for(const l of letters) {
          if(l.dataset.letter==active.letter)
            continue;
          const r = l.getBoundingClientRect();
          if (x+s.left >= r.left && x+s.left <= r.right && y+s.top >= r.top && y+s.top <= r.bottom) {
            onUp(ev);
            return;
          }
        }
        if(!last || Math.hypot(last.x-x,last.y-y) > 4) {
          active.pts.push({x,y});
          active.previewEl.setAttribute('points', active.pts.map(p=>p.x+','+p.y).join(' '));
        }
      }

      function onUp(ev){
        document.removeEventListener('mousemove', onMove);
        document.removeEventListener('mouseup', onUp);
        document.removeEventListener('touchmove', onMove);
        document.removeEventListener('touchend', onUp);
        const clientX = ev.clientX !== undefined ? ev.clientX : (ev.changedTouches && ev.changedTouches[0].clientX);
        const clientY = ev.clientY !== undefined ? ev.clientY : (ev.changedTouches && ev.changedTouches[0].clientY);
        const targetBox = letters.find(l=>{
          const r = l.getBoundingClientRect();
          return clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
        });
        if(targetBox && targetBox !== active.startEl && targetBox.dataset.letter === active.letter){
          active.pts.push(getCenter(targetBox));
          paths[active.letter] = active.pts;
          status.textContent = `Path set for ${active.letter}.`;
        }
        else {
          status.textContent = 'No valid matching target. Path discarded.';
        }
        const prev = svg.querySelector('[data-preview]');
        if(prev) prev.remove();
        active = null; redrawAll();
      }

      document.addEventListener('mousemove', onMove);
      document.addEventListener('mouseup', onUp);
      document.addEventListener('touchmove', onMove, {passive:false});
      document.addEventListener('touchend', onUp);
    }

    letters.forEach(el=>{
      el.addEventListener('mousedown', startDrawFromElement.bind(null, el));
      el.addEventListener('touchstart', e=>{
        e.preventDefault(); const t = e.touches[0];
        startDrawFromElement(el, t.clientX, t.clientY);
      });
    });

    // intersection code for segments
    function orient(p,q,r){ return (q.x-p.x)*(r.y-p.y) - (q.y-p.y)*(r.x-p.x); }
    function segIntersect(a,b,c,d){ const o1 = orient(a,b,c), o2 = orient(a,b,d), o3 = orient(c,d,a), o4 = orient(c,d,b); if(o1===0 && o2===0 && o3===0 && o4===0) return false; return (o1*o2<0) && (o3*o4<0); }

    function pathsIntersect(){
      const segs = [];
      for(const L of ['A','B','C']){
        const poly = paths[L]; if(!poly) continue;
        for(let i=0;i<poly.length-1;i++) segs.push({a:poly[i], b:poly[i+1], letter:L});
      }
      for(let i=0;i<segs.length;i++){
        for(let j=i+1;j<segs.length;j++){
          if(segs[i].letter === segs[j].letter) continue;
          if(segIntersect(segs[i].a,segs[i].b,segs[j].a,segs[j].b)) return {intersect:true, pair:[segs[i].letter,segs[j].letter]};
        }
      }
      return {intersect:false};
    }

    // controls
    document.getElementById('clear').addEventListener('click', ()=>{ paths.A = paths.B = paths.C = null; redrawAll(); status.textContent='Cleared.'; });
    document.getElementById('undo').addEventListener('click', ()=>{ if(paths.C){ paths.C = null; status.textContent='Removed C path.'; redrawAll(); return; } if(paths.B){ paths.B = null; status.textContent='Removed B path.'; redrawAll(); return; } if(paths.A){ paths.A = null; status.textContent='Removed A path.'; redrawAll(); return; } status.textContent='Nothing to undo.'; });

    document.getElementById('check').addEventListener('click', ()=>{
      if(!paths.A || !paths.B || !paths.C){ status.textContent='Please draw a path for A, B and C.'; return; }
      const intr = pathsIntersect();
      if(intr.intersect){ status.textContent = `Paths intersected between ${intr.pair[0]} and ${intr.pair[1]}. Try again.`; return; }
      status.textContent = 'No intersections detected — well done!';
      modal.classList.add('open');
    });

    document.getElementById('closeModal').addEventListener('click', ()=>{ modal.classList.remove('open'); });

    // initial render
    redrawAll();

    // accessibility: Enter to check
    document.addEventListener('keydown', e=>{ if(e.key==='Enter') document.getElementById('check').click(); });
  </script>
</body>
</html>